Данный репозиторий содержит файлы с контрольными работами.

# Решения задания к контрольной работе по первому блоку.

## Блок-схема по заданию.

![Иллюстрация к проекту1](https://github.com/daniil-koblov/Pictures_of-the-control_work/blob/main/Pictures_of_the_first_control_work/Block_diagram_of_the_control_work_on_the_first_block._Part_one..png)

![Иллюстрация к проекту2](https://github.com/daniil-koblov/Pictures_of-the-control_work/blob/main/Pictures_of_the_first_control_work/Block_diagram_of_the_control_work_on_the_first_block._Part_two..png)

![Иллюстрация к проекту3](https://github.com/daniil-koblov/Pictures_of-the-control_work/blob/main/Pictures_of_the_first_control_work/Block_diagram_of_the_control_work_on_the_first_block._Part_three..png)

## Условие:

* Задача: Написать программу, которая из имеющегося массива строк формирует массив из строк, длинна которых меньше либо равна 3.

## Примечание по решению:

* Я решил добавить в решение ручной ввод кол-ва символов, которое не должны первышать искомые строки. Поэтому в моей программе из имеющегося массива строк формирует массив из строк, длинна которых меньше либо равна введенному числу. Изпользуется переменна *countSymbol*.

* Также у мення вводятся строки из используемого массива, поэтому кол-во строк по шаблону можно расширять в необходимом кол-ве. В моем решении строки это *array1*, *array2*, *array3*, *array4*; а массив это *fullArray*.

* Решение использовать невозвратный метод *void* обусловленно тем, что мне необходимо было перезаписать строки в новый массив, длинна которого до нахохждения кол-ва строк неизвестна. Изменно поэтому в нем уже инициализируется новый массив строк и в него записываются строки с кол-вом символов, которое меньше или равно введенного числа.

## Решение:

1. Создается метод, в который перед входом необходимо занести массив строк *arrFull* и число *a*, которое ограничивает
кол-во символов.
2. Описание работы метода *void FillArray*, который не возвращает результат:
    * В методе сначала присваивается переменная *countMethood* (счетчик), которая считает кол-во подходящих строк.
    * После происходит первый цикл *for* на нахождение кол-ва подходящих под условие строк. 
    * Далее инициализируется новый массив *newArrFull* и переменная *j*, отвечающая за его индекс в следующем цикле.
    * Затем цикл в цикле. Наружный цикл *while* нужен для счетчика индексов позиций массива, в который записивываются подходящие под условие строки. Здесь необходимости в цикле формата *for* не было.
    * Во внутреннем цикле *for* перебор через счетчик индекса *i* с условием выхода пока *i* меньше длинных массива *arrFull* и прибавлением 1 к *i* после каждой инттерации цикла. 
    * Внутри цикла *for* проверка через *if* кол-ва символов каждой строки массива *arrFull* на меньшинство или равенство введенному числу *a*. Если кол-во символов в строке удовлетворяет условию *if*, то происходит запись строки в новый массив *newArrFull* и прибавляется 1 к счетчику нового массива строк *j*. После идет новый вход во внутренний цикл *for*, если *i*, с прибавленной еденицей, удовлетворяет условию.
    * Поcледний цикл *for* отвечает за вывод нового массива строк *newArrFull* в терминал. За индекс отвчает переменная *k*, условие пока индекс меньше длинны нового массива и после каждой иттерации просиходит прибавление еденицы к индексу. Внутри цикла просходит вывод каждого элемента (строки) на терминал.
3. Ручной ввод кол-ва символов, которое не должны первышать искомые строки. С проверкой введенного числа на равность или большинство числу 1.
4. Ручной ввод строк *array1*, *array2*, *array3*, *array4*.
5. Занесение строк в массив *fullArray*/
6. Использование массива строк *fullArray* и числа *countSymbol*, которое ограничивает кол-во символов в искомых строках, в методе *FullArray*. Далее смотрите пункт 2.